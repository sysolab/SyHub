# /home/<YOUR_USER>/syhub/flask_app_deployed.py
    # Flask application for the syHub Dashboard
    # Generated by syhub.sh from template flask_app.py.j2
    
    import os
    import yaml
    from flask import Flask, render_template, jsonify, send_from_directory, request
    import requests
    import logging
    import psutil
    from datetime import datetime
    
    # --- Configuration Loading ---
    # Load the config path from environment variable set by systemd service
    CONFIG_PATH = os.environ.get('SYHUB_CONFIG_PATH')
    if not CONFIG_PATH:
        print("FATAL ERROR: SYHUB_CONFIG_PATH environment variable not set.")
        exit(1) # Exit if config path is missing
    
    # Global cache for config to avoid repeated file reads
    _config_cache = None
    _config_last_loaded = None
    
    def load_config():
        """Loads configuration from the YAML file specified by CONFIG_PATH."""
        global _config_cache, _config_last_loaded
        try:
            # Basic caching: Reload if file changed (or first time)
            current_mtime = os.path.getmtime(CONFIG_PATH)
            if _config_cache and _config_last_loaded and current_mtime <= _config_last_loaded:
                return _config_cache
    
            with open(CONFIG_PATH, 'r') as f:
                config_full = yaml.safe_load(f)
                if not config_full:
                    raise ValueError("Config file is empty.")
    
            # Extract necessary values, providing safe defaults ONLY if absolutely critical
            config = {
                'project_name': config_full.get('project', {}).get('name', 'syHub'),
                'hostname': config_full.get('hostname', 'syhub.local'),
                'vm_port': config_full.get('victoria_metrics', {}).get('port', 8428),
                'vm_url': f"http://127.0.0.1:{config_full.get('victoria_metrics', {}).get('port', 8428)}",
                'dashboard_port': config_full.get('dashboard', {}).get('port', 5000),
                'mqtt_topic_telemetry': config_full.get('mqtt', {}).get('topic_telemetry', 'v1/devices/me/telemetry'),
                'base_dir': os.path.dirname(os.path.dirname(CONFIG_PATH)), # Derive base dir
                # Add other needed config values here
            }
            _config_cache = config
            _config_last_loaded = current_mtime
            logging.info(f"Configuration loaded successfully from {CONFIG_PATH}")
            return config
    
        except FileNotFoundError:
            logging.error(f"FATAL: Configuration file not found at {CONFIG_PATH}")
            # Cannot proceed without config
            exit(1)
        except Exception as e:
            logging.error(f"FATAL: Error loading or parsing config file {CONFIG_PATH}: {e}")
            # Cannot proceed without config
            exit(1)
    
    # --- Logging Setup ---
    logging.basicConfig(level=logging.INFO, format='%(asctime)s %(levelname)s: %(message)s')
    
    # --- Flask App Initialization ---
    # Determine directories based on derived base_dir from config path
    try:
        config = load_config()
        BASE_DIR = config['base_dir']
        STATIC_DIR = os.path.join(BASE_DIR, 'static')
        TEMPLATE_DIR = STATIC_DIR # Serve index.html from static dir itself
    
        # Ensure static directory exists
        if not os.path.isdir(STATIC_DIR):
             logging.error(f"Static directory not found at {STATIC_DIR}")
             # Decide how to handle this: exit or try to continue? Let's exit.
             exit(1)
    
        app = Flask(__name__, static_folder=STATIC_DIR, template_folder=TEMPLATE_DIR)
        logging.info(f"Flask app initialized. Static: {STATIC_DIR}, Templates: {TEMPLATE_DIR}")
    
    except Exception as e:
        logging.error(f"FATAL: Failed during Flask app initialization: {e}")
        exit(1)
    
    
    # --- VictoriaMetrics Client ---
    def query_vm(query):
        """Sends a PromQL query to VictoriaMetrics and returns the JSON response."""
        # Ensure config is loaded before querying
        current_config = load_config()
        if not current_config: return None # Should not happen due to exit checks
    
        vm_query_url = f"{current_config['vm_url']}/api/v1/query"
        try:
            response = requests.get(vm_query_url, params={'query': query}, timeout=5)
            response.raise_for_status() # Raise HTTPError for bad responses (4xx or 5xx)
            return response.json()
        except requests.exceptions.Timeout:
            logging.warning(f"Timeout querying VictoriaMetrics: {query}")
            return None
        except requests.exceptions.RequestException as e:
            logging.error(f"Error querying VictoriaMetrics ({vm_query_url}): {e}")
            return None
        except Exception as e:
            logging.error(f"Unexpected error during VictoriaMetrics query: {e}")
            return None
    
    # --- Routes ---
    @app.route('/')
    def index():
        """Serves the main dashboard page (index.html)."""
        try:
            current_config = load_config() # Refresh config in case it changed
            return render_template('index.html', project_name=current_config['project_name'])
        except Exception as e:
            logging.error(f"Error rendering index.html: {e}")
            return "Error loading dashboard page.", 500
    
    @app.route('/api/telemetry/latest')
    def get_latest_telemetry():
        """API endpoint to get the latest values for key metrics."""
        current_config = load_config()
        # Define metrics of interest - could potentially also be moved to config.yml
        metrics_to_query = ["temperature", "ph", "orp", "tds", "ec", "distance"]
        latest_data = {}
        query_errors = 0
    
        # Example PromQL query structure:
        # Assumes Node-RED writes metrics directly named (e.g., 'temperature', 'ph')
        # OR writes a generic metric like 'telemetry' with labels:
        # telemetry{topic="v1/...", metric_type="temperature"} value
        # We'll use the simpler direct name approach for this example:
        # `last_over_time(metric_name[5m])` - gets the last value within the last 5 minutes.
        for metric in metrics_to_query:
            query = f'last_over_time({metric}[5m])'
            result = query_vm(query)
            value = "N/A" # Default if no data or error
    
            if result and result.get('status') == 'success':
                if result.get('data', {}).get('result'):
                    try:
                        # Extract the most recent value: [timestamp, value]
                        raw_value = result['data']['result'][0]['value'][1]
                        # Try to convert to float for consistent formatting, keep as string if fails
                        try:
                            value = float(raw_value)
                        except (ValueError, TypeError):
                            value = str(raw_value) # Keep original string if not a number
                    except (IndexError, KeyError, TypeError) as e:
                        logging.warning(f"Error parsing VM result for {metric}: {e}, Raw: {result['data']}")
                        value = "Error"
                        query_errors += 1
                else:
                    # Query succeeded but no data points found in the time range
                    logging.debug(f"No recent data found for metric: {metric}")
                    value = "No Data"
            else:
                # Query failed or VM returned error status
                logging.warning(f"VM Query failed or returned error for metric: {metric}")
                value = "Error"
                query_errors += 1
    
            latest_data[metric] = value
    
        status_code = 503 if query_errors == len(metrics_to_query) else 200
        return jsonify(latest_data), status_code
    
    @app.route('/api/system/stats')
    def get_system_stats():
        """API endpoint for basic Raspberry Pi system statistics."""
        try:
            cpu_usage = psutil.cpu_percent(interval=0.1)
            memory_info = psutil.virtual_memory()
            disk_info = psutil.disk_usage('/')
            temp_info = {}
            if hasattr(psutil, "sensors_temperatures"):
                temps = psutil.sensors_temperatures()
                # Look for common Pi temperature sensors
                if 'cpu_thermal' in temps:
                    temp_info = temps['cpu_thermal'][0].current # Raspbian usually uses this
                elif 'coretemp' in temps: # Generic Linux
                     temp_info = temps['coretemp'][0].current
                else: # Try first available sensor
                    for key in temps:
                       if temps[key]:
                           temp_info = temps[key][0].current
                           break
    
    
            stats = {
                "cpu_percent": cpu_usage,
                "memory_percent": memory_info.percent,
                "memory_used_mb": round(memory_info.used / (1024 * 1024), 1),
                "memory_total_mb": round(memory_info.total / (1024 * 1024), 1),
                "disk_percent": disk_info.percent,
                "disk_used_gb": round(disk_info.used / (1024 * 1024 * 1024), 1),
                "disk_total_gb": round(disk_info.total / (1024 * 1024 * 1024), 1),
                "cpu_temperature_c": round(temp_info, 1) if isinstance(temp_info, (int, float)) else "N/A",
                "uptime_seconds": int(datetime.now().timestamp() - psutil.boot_time())
            }
            return jsonify(stats)
        except Exception as e:
            logging.error(f"Error getting system stats: {e}")
            return jsonify({"error": "Could not retrieve system stats"}), 500
    
    # Serve static files (CSS, JS) - Handled by Flask constructor static_folder
    
    # --- Main Execution ---
    if __name__ == '__main__':
        # This block runs only when executed directly (python flask_app_deployed.py)
        # Gunicorn will import the 'app' object directly using flask_app_deployed:app
        print(f"Starting Flask development server (for testing only)...")
        config = load_config() # Load config for standalone run
        if config:
             print(f"Access at: http://0.0.0.0:{config['dashboard_port']}")
             app.run(host='0.0.0.0', port=config.get('dashboard_port', 5000), debug=False) # Debug MUST be False for production/Gunicorn
        else:
            print("Failed to load configuration. Cannot start development server.")